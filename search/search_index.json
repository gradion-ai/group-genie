{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Group Genie","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Group Genie enables existing single-user AI agents to participate in group chat conversations without requiring modification to the agents themselves. While many AI agents excel at responding to direct queries from individual users, they typically cannot handle multi-party conversations where relevant information emerges from complex exchanges between multiple participants. Group Genie solves this by combining Group Sense's intelligent pattern detection with a flexible agent integration layer. Agents can be based on any technology stack (framework, API, etc.) and integrated through a simple agent interface, with default implementations provided for Pydantic AI and the OpenAI Agents SDK.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>Group conversation understanding: Built on Group Sense, which monitors group chats, detects conversation patterns, and reformulates multi-party exchanges into self-contained queries that AI agents can process.</p> </li> <li> <p>Dynamic response routing: Group Sense reasoners determine recipients of agent responses based on conversation context and semantics, enabling agents to respond to appropriate group members.</p> </li> <li> <p>Agent connectors: Connect existing AI agents to group chats without modification. Default connectors are provided for Pydantic AI and the OpenAI Agents SDK, based on a simple interface.</p> </li> <li> <p>Agent hierarchies: Organize agents into coordinator-subagent hierarchies of any depth, each having their own context window for focused conversations and task-specific expertise.</p> </li> <li> <p>User-specific credentials: Agents can act on behalf of individual group members using their credentials, enabling secure access to a user's private resources while maintaining proper access boundaries to other users.</p> </li> <li> <p>Agent lifecycle management: Configurable idle timeouts optimize resource usage by automatically stopping idle agents and freeing their memory and MCP server connections.</p> </li> <li> <p>Session persistence: File-based persistence for group chat messages and agent states allows group sessions to be suspended and resumed.</p> </li> <li> <p>Unified tool approval mechanism: Consistent approval workflow for tool calls across agent hierarchies, with support for manual and automatic approval modes.</p> </li> <li> <p>Rich message support: Handles message attachments with automatic propagation through agent chains. Thread references provide context from related group chats.</p> </li> </ul>"},{"location":"#next-steps","title":"Next steps","text":"<ol> <li>Install the library and configure API keys</li> <li>Follow the tutorial to build your first group chat agent</li> <li>Learn how to integrate Group Genie into your application</li> </ol>"},{"location":"#llm-optimized-documentation","title":"LLM-optimized documentation","text":"<ul> <li>llms.txt</li> <li>llms-full.txt</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#python-package","title":"Python Package","text":"<pre><code>pip install group-genie\n</code></pre>"},{"location":"installation/#development-setup","title":"Development Setup","text":"<p>For setting up a development environment, see DEVELOPMENT.md.</p>"},{"location":"integration/","title":"Chat Server Integration","text":"<p>This guide demonstrates how to integrate Group Genie into a chat server to enable multi-party reasoning and agent responses in group chat environments. We'll use the group-terminal chat server as a reference implementation, but the patterns apply to any chat server architecture.</p> <p>Note</p> <p>This integration guide assumes you are familiar with the Group Genie tutorial.</p>"},{"location":"integration/#overview","title":"Overview","text":"<p>Integrating Group Genie into a chat server involves connecting two key components:</p> <ol> <li>Chat Server: Receives messages from users and broadcasts responses back to connected clients</li> <li>Group Session: Processes messages through group reasoning and agent execution and publishes responses to the group.</li> </ol>"},{"location":"integration/#key-integration-points","title":"Key Integration Points","text":"<p>A chat server usually provides two integration points. The following are specific to the group-terminal chat server:</p> <ol> <li> <p>Message Handler: A callback that receives incoming messages from chat clients</p> <ul> <li>Signature: <code>async def handler(content: str, sender: str)</code></li> <li>Called sequentially in message arrival order</li> <li>Must be non-blocking to avoid delaying subsequent messages</li> </ul> </li> <li> <p>Send Message: A method to broadcast responses back to chat clients</p> <ul> <li>Signature: <code>async def send_message(content: str, sender: str)</code></li> <li>Called from message processing tasks to deliver agent responses</li> </ul> </li> </ol>"},{"location":"integration/#implementation-pattern","title":"Implementation Pattern","text":""},{"location":"integration/#message-ingestion","title":"Message Ingestion","text":"<pre><code>from asyncio import create_task\nfrom group_terminal.server import ChatServer\nfrom group_genie.session import GroupSession\nfrom group_genie.message import Message\n\nclass App:\n    def __init__(\n        self,\n        group_reasoner_factory,\n        agent_factory,\n        session_id,\n        host=\"0.0.0.0\",\n        port=8723,\n    ):\n        # Initialize Group Session\n        self._session = GroupSession(\n            id=session_id,\n            group_reasoner_factory=group_reasoner_factory,\n            agent_factory=agent_factory,\n            data_store=data_store,\n        )\n\n        # Initialize chat server and register message handler\n        self._server = ChatServer(host=host, port=port)\n        self._server.add_handler(self._handle_message)\n\n    async def _handle_message(self, content: str, sender: str):\n        # Create Group Genie message from chat message\n        message = Message(content=content, sender=sender)\n\n        # Add message to session in arrival order\n        # handle() must be called sequentially\n        # to maintain consistent message ordering\n        execution = self._session.handle(message)\n\n        # Process messages asynchronously to avoid blocking\n        # the message handler from receiving subsequent messages\n        create_task(self._complete_execution(execution))\n</code></pre> <p>Message ingestion includes:</p> <ul> <li><code>session.handle(message)</code> is called synchronously in the message handler, ensuring messages are added to the session in arrival order</li> <li><code>create_task()</code> runs the message processing coroutine asynchronously, allowing the message handler to return immediately and receive the next message</li> <li>This design maintains ordering guarantees while preventing long-running agent executions from blocking the message queue</li> </ul>"},{"location":"integration/#message-processing","title":"Message Processing","text":"<p>The <code>_complete_execution()</code> message processing coroutine processes three types of elements from an <code>Execution</code> stream:</p> <pre><code>from group_genie.session import Execution\nfrom group_genie.agent import Approval, Decision\nfrom group_genie.message import Message\n\nasync def _complete_execution(self, execution: Execution):\n    async for elem in execution.stream():\n        match elem:\n            case Decision() as decision:\n                # Group reasoner decided to IGNORE or DELEGATE\n                logger.debug(f\"Reasoner decision: {decision.value}\")\n\n            case Approval() as approval:\n                # Agent requests tool call approval\n                logger.debug(f\"Auto-approve {approval}\")\n                elem.approve()\n\n            case Message() as message:\n                # Agent generated a response message\n                logger.debug(f\"Agent response: {message.content}\")\n                await self._server.send_message(\n                    message.content,\n                    sender=message.sender\n                )\n</code></pre> <ul> <li>Decision: Logs the group reasoner's decision (IGNORE or DELEGATE). If IGNORE, the stream completes with no further elements.</li> <li>Approval: Handles tool call approval requests. In this example, all tool calls are auto-approved. Production systems might implement manual approval workflows.</li> <li>Message: Send agent responses back to chat clients via the server's <code>send_message</code> method.</li> </ul>"},{"location":"integration/#complete-example","title":"Complete Example","text":"<p>The complete example is available at examples/guide/chat.py.</p>"},{"location":"integration/#running-the-example","title":"Running the Example","text":"<p>Start the chat server with the fact-checking template:</p> <pre><code>python examples/guide/chat.py --template-name fact_check\n</code></pre> <p>In separate terminals, launch three clients:</p> <pre><code>python -m group_terminal.client --username user1\npython -m group_terminal.client --username user2\npython -m group_terminal.client --username user3\n</code></pre>"},{"location":"integration/#example-conversation","title":"Example Conversation","text":"<p>The screenshots below show the fact-checking scenario from the tutorial, but running in a group chat environment. The same three users (user1, user2, user3) participate in the conversation:</p> <p><code>user1</code>'s view: </p> <p><code>user2</code>'s view: </p> <p><code>user3</code>'s view: </p> <p>The group reasoner detects the factual inconsistency (Hofbr\u00e4uhaus is in Munich, not Vienna) and delegates to the system agent to resolve it.</p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This tutorial walks you through a complete example that demonstrates how Group Genie enables AI agents to participate in group chat conversations. You'll learn how to set up a group session, configure a group reasoner to detect conversation patterns, and connect an agent that responds to queries generated by the group reasoner.</p>"},{"location":"tutorial/#about-group-genie","title":"About Group Genie","text":"<p>While many AI agents excel at responding to direct queries from individual users, they typically cannot handle multi-party conversations where relevant information emerges from complex exchanges between multiple participants. Group Genie combines Group Sense's intelligent pattern detection with a flexible agent integration layer, allowing existing single-user agents to participate naturally in group chats without requiring any modification to the agents themselves.</p>"},{"location":"tutorial/#example-scenario","title":"Example Scenario","text":"<p>In this example, we'll create a fact-checking assistant that monitors a group chat for factual inconsistencies. When the group reasoner detects contradictory statements, it sends a self-contained query, reformulated from the conversation context, to the system agent to verify facts through web search and respond to the group.</p> <p>Consider this group chat exchange:</p> <ul> <li><code>user1</code>: \"I'm going to Vienna tomorrow\"</li> <li><code>user2</code>: \"Enjoy your time there!\"</li> <li><code>user3</code>: \"Cool, plan a visit to the Hofbr\u00e4uhaus!\"</li> </ul> <p>The third message contains a factual inconsistency (Hofbr\u00e4uhaus is in Munich, not Vienna). The group reasoner will detect this and delegate to the system agent, which will search the web, identify the mistake, and respond with a clarification.</p>"},{"location":"tutorial/#core-components","title":"Core Components","text":"<p>The tutorial demonstrates four essential components:</p>"},{"location":"tutorial/#group-session","title":"Group Session","text":"<p><code>GroupSession</code> is the main entry point that orchestrates message flow through group reasoners and agents. It provides concurrent processing for different users while ensuring messages from the same sender are processed sequentially. It also manages the lifecycle of both reasoners and agents.</p>"},{"location":"tutorial/#group-reasoner","title":"Group Reasoner","text":"<p>A <code>GroupReasoner</code> analyzes group chat messages and decides whether to ignore them or generate queries for agents. In this example, we use <code>DefaultGroupReasoner</code> configured with a fact-checking prompt that detects contradictory statements between messages.</p>"},{"location":"tutorial/#system-agent","title":"System Agent","text":"<p>The system agent is the primary target for processing delegated queries generated by the group reasoner. It can be any <code>Agent</code>; the name system agent reflects that it can serve as a facade to a larger system of agents (e.g. acting as a coordinator that delegates to subagents), but it can also be a standalone agent that directly handles queries.</p> <p>In this example, we use a standalone <code>DefaultAgent</code> with access to web search through an MCP server, allowing it to verify facts by searching online.</p>"},{"location":"tutorial/#factories","title":"Factories","text":"<p>Each group chat participant owns both a group reasoner instance and a system agent instance, allowing independent reasoning state and credentials. These are created by:</p> <ul> <li><code>GroupReasonerFactory</code> creates group reasoners with user-specific system prompts and reasoning states</li> <li><code>AgentFactory</code> creates system agent instances with user-specific credentials, enabling agents to act on behalf of individual group members</li> </ul>"},{"location":"tutorial/#implementation-walkthrough","title":"Implementation Walkthrough","text":""},{"location":"tutorial/#secrets-provider","title":"Secrets Provider","text":"<p>We implement <code>SecretsProvider</code>, an interface designed to retrieve user-specific credentials:</p> examples/factory/provider.py<pre><code>import os\n\nfrom group_genie.secrets import SecretsProvider\n\n\nclass EnvironmentSecretsProvider(SecretsProvider):\n    def get_secrets(self, username: str) -&gt; dict[str, str] | None:\n        # For development: use environment variables for all users\n        return {\n            \"GOOGLE_API_KEY\": os.getenv(\"GOOGLE_API_KEY\", \"\"),\n            \"BRAVE_API_KEY\": os.getenv(\"BRAVE_API_KEY\", \"\"),\n        }\n</code></pre> <p>In this development example, we just return the same set of environment variables for all users. In production, you would implement per-user credential storage and retrieval.</p>"},{"location":"tutorial/#group-reasoner-factory","title":"Group Reasoner Factory","text":"<p>We use the <code>get_group_reasoner_factory</code> helper to obtain a <code>GroupReasonerFactory</code> for creating user-specific reasoner instances:</p> examples/factory/reasoner.py<pre><code>from functools import partial\n\nfrom pydantic_ai.models.google import GoogleModel\nfrom pydantic_ai.providers.google import GoogleProvider\n\nfrom examples.utils import load_reasoner_template\nfrom group_genie.agent.provider.pydantic_ai import DefaultGroupReasoner\nfrom group_genie.reasoner import GroupReasoner, GroupReasonerFactory\nfrom group_genie.secrets import SecretsProvider\n\n\ndef create_group_reasoner(\n    system_template: str,\n    secrets: dict[str, str],\n    owner: str,\n) -&gt; GroupReasoner:\n    model = GoogleModel(\n        \"gemini-2.5-flash\",\n        provider=GoogleProvider(api_key=secrets.get(\"GOOGLE_API_KEY\", \"\")),\n    )\n    return DefaultGroupReasoner(\n        system_prompt=system_template.format(owner=owner),\n        model=model,\n    )\n\n\ndef get_group_reasoner_factory(\n    secrets_provider: SecretsProvider | None = None,\n    template_name: str = \"general_assist\",\n):\n    system_template = load_reasoner_template(template_name)\n    return GroupReasonerFactory(\n        group_reasoner_factory_fn=partial(create_group_reasoner, system_template),\n        secrets_provider=secrets_provider,\n    )\n</code></pre> <p>The <code>create_group_reasoner</code> function receives a system prompt template, secrets, and the owner's username and returns a configured <code>GroupReasoner</code>. It:</p> <ol> <li>Creates a Gemini model instance with the owner's Google API key from their secrets</li> <li>Formats the system prompt template with the owner's username</li> <li>Returns a <code>DefaultGroupReasoner</code> configured with the formatted system prompt and model</li> </ol>"},{"location":"tutorial/#agent-factory","title":"Agent Factory","text":"<p>We use the <code>get_agent_factory</code> helper to obtain an <code>AgentFactory</code> for creating user-specific system agent instances:</p> examples/factory/agent_1.py<pre><code>from pydantic_ai.mcp import MCPServerStdio\nfrom pydantic_ai.models.google import GoogleModel, GoogleModelSettings\nfrom pydantic_ai.providers.google import GoogleProvider\n\nfrom group_genie.agent import Agent, AgentFactory\nfrom group_genie.agent.provider.pydantic_ai import DefaultAgent\nfrom group_genie.secrets import SecretsProvider\n\n\ndef create_system_agent(secrets: dict[str, str]) -&gt; Agent:\n    brave_mcp_server = MCPServerStdio(\n        command=\"npx\",\n        args=[\"-y\", \"@modelcontextprotocol/server-brave-search\"],\n        env={\n            \"BRAVE_API_KEY\": secrets.get(\"BRAVE_API_KEY\", \"\"),\n        },\n    )\n\n    model = GoogleModel(\n        \"gemini-2.5-flash\",\n        provider=GoogleProvider(api_key=secrets.get(\"GOOGLE_API_KEY\", \"\")),\n    )\n\n    return DefaultAgent(\n        system_prompt=(\n            \"You are a helpful assistant. \"\n            \"Always search the web for checking facts. \"\n            \"Provide short, concise answers.\"\n        ),\n        model=model,\n        model_settings=GoogleModelSettings(\n            google_thinking_config={\n                \"thinking_budget\": 0,\n            }\n        ),\n        toolsets=[brave_mcp_server],\n    )\n\n\ndef get_agent_factory(secrets_provider: SecretsProvider | None = None):\n    return AgentFactory(\n        system_agent_factory=create_system_agent,\n        secrets_provider=secrets_provider,\n    )\n</code></pre> <p>The <code>create_system_agent</code> function receives the owner's secrets and returns a configured <code>Agent</code>. It:</p> <ol> <li>Configures a Brave Search MCP server with the owner's Brave API key</li> <li>Configures a Gemini model instance with the owner's Google API key</li> <li>Returns a <code>DefaultAgent</code> configured with:<ul> <li>A system prompt instructing it to search the web for fact-checking</li> <li>The configured Gemini model</li> <li>The configured Brave Search MCP server</li> </ul> </li> </ol>"},{"location":"tutorial/#group-session_1","title":"Group Session","text":"<p>Now we bring everything together by creating a <code>GroupSession</code>:</p> examples/guide/tutorial.py<pre><code>import asyncio\nimport logging\nfrom pathlib import Path\nfrom uuid import uuid4\n\nfrom examples.factory.agent_1 import get_agent_factory\nfrom examples.factory.provider import EnvironmentSecretsProvider\nfrom examples.factory.reasoner import get_group_reasoner_factory\nfrom group_genie.agent import Approval, Decision\nfrom group_genie.datastore import DataStore\nfrom group_genie.message import Message\nfrom group_genie.session import Execution, GroupSession\n\n\nasync def complete_execution(execution: Execution) -&gt; None:\n    async for elem in execution.stream():\n        match elem:\n            case Decision():\n                # log group reasoner decision\n                logger.debug(elem)\n            case Approval():\n                # log tool call approval request\n                logger.debug(elem)\n                # approve tool call\n                elem.approve()\n            case Message():\n                # log agent response\n                logger.debug(elem)\n\n\nsecrets_provider = EnvironmentSecretsProvider()\nsession_id = uuid4().hex[:8]\nsession = GroupSession(\n    id=session_id,\n    group_reasoner_factory=get_group_reasoner_factory(\n        secrets_provider=secrets_provider,\n        template_name=\"fact_check\",\n    ),\n    agent_factory=get_agent_factory(secrets_provider=secrets_provider),\n    data_store=DataStore(root_path=Path(\".data\", \"quickstart\", session_id)),\n)\n\nchat = [  # example group chat messages\n    # no factual inconsistency, group reasoner will ignore the message.\n    Message(content=\"I'm going to Vienna tomorrow\", sender=\"user1\"),\n    # no factual inconsistency, group reasoner will ignore the message.\n    Message(content=\"Enjoy your time there!\", sender=\"user2\"),\n    # factual inconsistency in response to user1's message.\n    # Group reasoner will delegate to system agent for fact checking.\n    Message(content=\"Cool, plan a visit to the Hofbr\u00e4uhaus!\", sender=\"user3\"),\n]\n\n# Add chat messages to session and create execution objects\nexecutions = [session.handle(msg) for msg in chat]\n\n# Concurrently process group chat messages. The complete_execution()\n# helper logs reasoner decisions and agent responses to the console.\ncoros = [complete_execution(exec) for exec in executions]\nawait asyncio.gather(*coros)\n</code></pre> <p>This code:</p> <ol> <li>Creates a secrets provider to supply API keys</li> <li>Generates a unique session ID for this group chat</li> <li>Initializes a <code>GroupSession</code> with:<ul> <li>A group reasoner factory configured for fact-checking</li> <li>An agent factory that creates system agents with web search capabilities</li> <li>A <code>DataStore</code> for persisting messages, reasoner and agent states</li> </ul> </li> <li>Defines a sample group chat with three messages, where the third contains a factual inconsistency</li> <li>Handles each message by calling <code>handle()</code>, which returns an <code>Execution</code> object</li> <li>Concurrently consumes execution <code>stream</code>s with the <code>complete_execution</code> helper and <code>asyncio.gather()</code></li> </ol> <p>An execution <code>stream</code> yields three types of elements:</p> <ul> <li><code>Decision</code>: The group reasoner's decision about whether to ignore or delegate the message</li> <li><code>Approval</code>: Requests for approval of tool calls (e.g., web searches)</li> <li><code>Message</code>: The agent's response to be sent to the group</li> </ul> <p>In this example, we log all events and automatically approve all tool calls. In a production application, you might implement selective approval logic or user confirmation for sensitive operations.</p>"},{"location":"tutorial/#running-the-example","title":"Running the Example","text":"<p>Development Setup</p> <p>To set up the environment for running the example, see Development Setup.</p> <p>To run this example:</p> <ol> <li> <p>Set up your API keys:    <pre><code>export GOOGLE_API_KEY=\"your-gemini-api-key\"\nexport BRAVE_API_KEY=\"your-brave-search-api-key\"\n</code></pre></p> </li> <li> <p>Run the tutorial script:    <pre><code>python examples/guide/tutorial.py\n</code></pre></p> </li> </ol> <p>The output will show the group reasoner detecting the factual contradiction and the agent searching the web to verify that Hofbr\u00e4uhaus is actually in Munich, not Vienna. The agent will then generate a response clarifying this mistake for the group. The output should look like this:</p> <pre><code>2025-11-05 11:06:15,947 DEBUG __main__: Decision.IGNORE\n2025-11-05 11:06:17,085 DEBUG __main__: Decision.IGNORE\n2025-11-05 11:06:19,526 DEBUG __main__: Decision.DELEGATE\n2025-11-05 11:06:20,336 DEBUG __main__: [sender=\"system\"] brave_web_search(query='Hofbr\u00e4uhaus location')\n2025-11-05 11:06:22,399 DEBUG __main__: Message(content='The Hofbr\u00e4uhaus is a famous beer hall located in Munich, Germany, not Vienna, Austria. Therefore, a visit to the Hofbr\u00e4uhaus would not be possible if you are going to Vienna.', sender='system', receiver=None, threads=[], attachments=[], request_id=None)\n</code></pre>"},{"location":"api/agent/","title":"Agent","text":""},{"location":"api/agent/#group_genie.agent.Agent","title":"group_genie.agent.Agent","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for creating custom agents.</p> <p>Agents are the core processing units that handle delegated queries from group reasoners. They can be standalone agents or coordinator agents that orchestrate subagents in a hierarchical architecture.</p> <p>Implementations must handle conversation state serialization (via <code>get_serialized</code> and <code>set_serialized</code>), MCP server lifecycle management (via <code>mcp</code> context manager), and query processing with tool approval callbacks.</p> <p>State persistence is managed automatically by the framework and stored in JSON format. Persisted state is never transferred between different owners (users).</p> Example <pre><code>class MyAgent(Agent):\n    def __init__(self, system_prompt: str):\n        self._history = []\n        self._system_prompt = system_prompt\n\n    def get_serialized(self):\n        return {\"history\": self._history}\n\n    def set_serialized(self, state):\n        self._history = state[\"history\"]\n\n    @asynccontextmanager\n    async def mcp(self):\n        # Initialize MCP servers if needed\n        yield self\n\n    async def run(self, input: AgentInput, callback: ApprovalCallback) -&gt; str:\n        # Process query and return response\n        return f\"Processed: {input.query}\"\n</code></pre>"},{"location":"api/agent/#group_genie.agent.Agent.get_serialized","title":"get_serialized  <code>abstractmethod</code>","text":"<pre><code>get_serialized() -&gt; Any\n</code></pre> <p>Serialize agent state for persistence.</p> <p>Returns conversation history and any other state needed to resume the agent after a restart. Called automatically by the framework before saving to <code>DataStore</code>.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Serializable state (must be JSON-compatible). Implementation-specific format.</p>"},{"location":"api/agent/#group_genie.agent.Agent.mcp","title":"mcp  <code>abstractmethod</code>","text":"<pre><code>mcp() -&gt; AbstractAsyncContextManager[Agent]\n</code></pre> <p>Context manager for MCP server lifecycle.</p> <p>Manages the lifecycle of any MCP (Model Context Protocol) servers used by this agent. Connects to the agent's MCP servers on entering the context, and disconnects on exit.</p> <p>Returns:</p> Type Description <code>AbstractAsyncContextManager[Agent]</code> <p>Async context manager that yields self.</p>"},{"location":"api/agent/#group_genie.agent.Agent.run","title":"run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>run(input: AgentInput, callback: ApprovalCallback) -&gt; str\n</code></pre> <p>Process a query and return a response.</p> <p>Executes the agent's core logic to process the query. Must use the provided callback for any tool calls that require approval. Agent execution blocks until all approvals are granted or denied.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>AgentInput</code> <p>The query and associated data to process.</p> required <code>callback</code> <code>ApprovalCallback</code> <p>Async callback for requesting approval of tool calls. Must be called for any tool execution that requires user approval.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The agent's response as a string.</p>"},{"location":"api/agent/#group_genie.agent.Agent.set_serialized","title":"set_serialized  <code>abstractmethod</code>","text":"<pre><code>set_serialized(state: Any)\n</code></pre> <p>Restore agent state from serialized data.</p> <p>Reconstructs conversation history and internal state from previously serialized data. Called automatically by the framework after loading from <code>DataStore</code>.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>Any</code> <p>Previously serialized state from <code>get_serialized()</code>.</p> required"},{"location":"api/agent/#group_genie.agent.AgentInput","title":"group_genie.agent.AgentInput  <code>dataclass</code>","text":"<pre><code>AgentInput(query: str, attachments: list[Attachment] = list(), preferences: str | None = None)\n</code></pre> <p>Input data for agent execution.</p> <p>Encapsulates all information needed for an agent to process a query, including the query text, any attached files, and user-specific preferences.</p> <p>Attributes:</p> Name Type Description <code>query</code> <code>str</code> <p>The query text for the agent to process. Should be self-contained with all necessary context.</p> <code>attachments</code> <code>list[Attachment]</code> <p>List of file attachments that accompany the query.</p> <code>preferences</code> <code>str | None</code> <p>Optional user-specific preferences that customize the agent's response style and format. Typically a free-form string with bullet points.</p> Example <pre><code>input = AgentInput(\n    query=\"Analyze this report and summarize key findings\",\n    attachments=[Attachment(\n        path=\"/tmp/report.pdf\",\n        name=\"Q3 Report\",\n        media_type=\"application/pdf\"\n    )],\n    preferences=\"Concise responses, no emojis\"\n)\n</code></pre>"},{"location":"api/agent/#group_genie.agent.AgentInfo","title":"group_genie.agent.AgentInfo  <code>dataclass</code>","text":"<pre><code>AgentInfo(name: str, description: str, emoji: str | None = None, idle_timeout: float | None = None)\n</code></pre> <p>Metadata about an agent.</p> <p>Provides descriptive information about an agent for configuration purposes. Used by <code>AgentFactory</code> coordinator agents to learn about available subagents.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique identifier for the agent (e.g., \"search\", \"math\", \"system\").</p> <code>description</code> <code>str</code> <p>Description of the agent's capabilities and purpose. Used by coordinator agents to select subagents.</p> <code>emoji</code> <code>str | None</code> <p>Optional emoji code for visual identification.</p> <code>idle_timeout</code> <code>float | None</code> <p>Optional timeout in seconds after which an idle agent is stopped to free resources. None means no timeout.</p> Example <pre><code>info = AgentInfo(\n    name=\"search\",\n    description=\"Searches the web for current information\",\n    emoji=\"mag\",\n    idle_timeout=300.0\n)\n</code></pre>"},{"location":"api/agent/#group_genie.agent.AgentRunner","title":"group_genie.agent.AgentRunner","text":"<pre><code>AgentRunner(key: str, name: str, owner: str, agent_factory: AgentFactory, data_store: DataStore | None = None, extra_tools: dict[str, AsyncTool] | None = None)\n</code></pre>"},{"location":"api/agent/#group_genie.agent.AgentRunner.run_subagent","title":"run_subagent  <code>async</code>","text":"<pre><code>run_subagent(query: str, subagent_name: str, subagent_instance: str | None = None, attachments: list[Attachment] = []) -&gt; str\n</code></pre> <p>Runs a subagent and returns its response.</p> <p>Subagents maintain state between runs. If you want to re-use a subagent instance, e.g. for a follow-up query or for an ongoing conversation with a subagent, set the <code>subagent_instance</code> to the instance id of a previously created subagent instance.</p> <p>Pass attachments metadata to the subagent only if you think it is required by the subagent to process the query. If you have received attachments in a query message, and already extracted the required information from them, do not pass them to the subagent.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to run the subagent with.</p> required <code>subagent_name</code> <code>str</code> <p>The name of the subagent to run.</p> required <code>subagent_instance</code> <code>str | None</code> <p>The 8-digit hex instance id of the subagent to run. If <code>null</code>, a new subagent instance will be created.</p> <code>None</code> <code>attachments</code> <code>list[Attachment]</code> <p>The attachments metadata to pass to the subagent.</p> <code>[]</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing the subagent name, 8-digit hex instance id, and response, e.g. <pre><code>{\n    \"subagent_name\": subagent name,\n        \"subagent_instance\": subagent 8-digit hex instance id,\n        \"subagent_response\": subagent response,\n}\n</code></pre></p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the name of the subagent does not exist.</p>"},{"location":"api/agent/#group_genie.agent.Approval","title":"group_genie.agent.Approval  <code>dataclass</code>","text":"<pre><code>Approval(sender: str, tool_name: str, tool_args: tuple, tool_kwargs: dict[str, Any], ftr: Future[bool])\n</code></pre> <p>Represents a tool call awaiting user approval.</p> <p><code>Approval</code> objects are emitted by <code>Execution.stream()</code> when an agent attempts to call a tool that requires approval. Applications must approve or deny the request by calling <code>approve()</code> or <code>deny()</code>, which unblocks the agent execution.</p> <p>Attributes:</p> Name Type Description <code>sender</code> <code>str</code> <p>Identifier of the agent or subagent requesting approval (e.g., \"system\", \"search:a1b2c3d4\").</p> <code>tool_name</code> <code>str</code> <p>Name of the tool being called.</p> <code>tool_args</code> <code>tuple</code> <p>Positional arguments for the tool call.</p> <code>tool_kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for the tool call.</p> <code>ftr</code> <code>Future[bool]</code> <p>Internal future for communicating the approval decision.</p> Example <pre><code>async for elem in execution.stream():\n    match elem:\n        case Approval() as approval:\n            print(f\"Tool call: {approval.call_repr()}\")\n            if is_safe(approval.tool_name):\n                approval.approve()\n            else:\n                approval.deny()\n</code></pre>"},{"location":"api/agent/#group_genie.agent.Approval.approve","title":"approve","text":"<pre><code>approve()\n</code></pre> <p>Approve the tool call and unblock agent execution.</p> <p>Allows the agent to proceed with the tool execution. The agent will receive the tool's result.</p>"},{"location":"api/agent/#group_genie.agent.Approval.approved","title":"approved  <code>async</code>","text":"<pre><code>approved() -&gt; bool\n</code></pre> <p>Wait for and return the approval decision.</p> <p>Blocks until approve() or deny() is called, then returns the decision.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if approved, False if denied.</p>"},{"location":"api/agent/#group_genie.agent.Approval.call_repr","title":"call_repr","text":"<pre><code>call_repr() -&gt; str\n</code></pre> <p>Get a string representation of the tool call.</p>"},{"location":"api/agent/#group_genie.agent.Approval.deny","title":"deny","text":"<pre><code>deny()\n</code></pre> <p>Deny the tool call and unblock agent execution.</p> <p>Prevents the tool from executing. The agent will receive a denial message (implementation-specific behavior).</p>"},{"location":"api/agent/#group_genie.agent.ApprovalCallback","title":"group_genie.agent.ApprovalCallback  <code>module-attribute</code>","text":"<pre><code>ApprovalCallback = Callable[[str, dict[str, Any]], Awaitable[bool]]\n</code></pre> <p>Callback function type for requesting approval of tool calls.</p> <p>When called, approval is requested and blocks until the application approves or denies the request. This callback is typically provided by <code>ApprovalContext.approval_callback()</code> and passed to <code>Agent.run()</code> to enable approval workflows.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <p>Name of the tool being called.</p> required <code>tool_args</code> <p>Keyword arguments for the tool call.</p> required <p>Returns:</p> Type Description <p>True if the tool call is approved, False if denied.</p>"},{"location":"api/agent/#group_genie.agent.ApprovalContext","title":"group_genie.agent.ApprovalContext  <code>dataclass</code>","text":"<pre><code>ApprovalContext(queue: Queue[Approval], auto_approve: bool = False)\n</code></pre> <p>Context for managing the approval workflow.</p> <p><code>ApprovalContext</code> coordinates approval requests between agents and the application. It manages a queue of <code>Approval</code> objects that are emitted through <code>Execution.stream()</code> and provides callbacks for agents to request approval.</p> <p>When auto_approve is enabled, all tool calls are automatically approved and <code>Approval</code> objects are not emitted through the stream.</p> <p>Attributes:</p> Name Type Description <code>queue</code> <code>Queue[Approval]</code> <p>Queue for Approval objects that need user attention.</p> <code>auto_approve</code> <code>bool</code> <p>If True, automatically approve all tool calls without emitting Approvals. Defaults to False.</p> Example <pre><code># Auto-approve mode (used by Execution.result())\ncontext = ApprovalContext(queue=queue, auto_approve=True)\n\n# Manual approval mode (used by Execution.stream())\ncontext = ApprovalContext(queue=queue, auto_approve=False)\n</code></pre>"},{"location":"api/agent/#group_genie.agent.ApprovalContext.approval","title":"approval  <code>async</code>","text":"<pre><code>approval(sender: str, tool_name: str, tool_args: dict[str, Any]) -&gt; bool\n</code></pre> <p>Request approval for a tool call.</p> <p>If auto_approve is enabled, immediately returns True. Otherwise, creates an <code>Approval</code> object, adds it to the queue for the application to handle, and blocks until <code>approve()</code> or <code>deny()</code> is called.</p> <p>Parameters:</p> Name Type Description Default <code>sender</code> <code>str</code> <p>Identifier of the agent requesting approval.</p> required <code>tool_name</code> <code>str</code> <p>Name of the tool being called.</p> required <code>tool_args</code> <code>dict[str, Any]</code> <p>Arguments for the tool call.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if approved, False if denied.</p>"},{"location":"api/agent/#group_genie.agent.ApprovalContext.approval_callback","title":"approval_callback","text":"<pre><code>approval_callback(sender: str) -&gt; ApprovalCallback\n</code></pre> <p>Create an approval callback for a specific sender.</p> <p>Parameters:</p> Name Type Description Default <code>sender</code> <code>str</code> <p>Identifier of the agent requesting approval.</p> required <p>Returns:</p> Type Description <code>ApprovalCallback</code> <p>Callback function that can be passed to <code>Agent.run()</code>.</p>"},{"location":"api/agent/#group_genie.agent.AgentFactory","title":"group_genie.agent.AgentFactory","text":"<pre><code>AgentFactory(system_agent_factory: SingleAgentFactoryFn | MultiAgentFactoryFn, system_agent_info: AgentInfo | None = None, secrets_provider: SecretsProvider | None = None)\n</code></pre> <p>Factory for creating agent instances.</p> <p><code>AgentFactory</code> provides centralized agent creation and configuration. It supports two types of agents:</p> <ol> <li> <p>Standalone agents (SingleAgentFactoryFn): Simple agents that process queries    independently without subagent orchestration.</p> </li> <li> <p>Coordinator agents (MultiAgentFactoryFn): Complex agents that can run other    agents as subagents, receiving information about available subagents and    extra tools (like run_subagent).</p> </li> </ol> <p>The factory automatically provides user-specific secrets to agents and maintains agent metadata for introspection.</p> Example <pre><code># Standalone agent factory\ndef create_search_agent(secrets: dict[str, str]) -&gt; Agent:\n    return DefaultAgent(\n        system_prompt=\"You are a search specialist\",\n        model=\"gemini-2.5-flash\",\n        builtin_tools=[WebSearchTool()],\n    )\n\n# Coordinator agent factory\ndef create_coordinator(\n    secrets: dict[str, str],\n    extra_tools: dict[str, AsyncTool],\n    agent_infos: list[AgentInfo]\n) -&gt; Agent:\n    # Has access to run_subagent tool and info about subagents\n    return DefaultAgent(\n        system_prompt=f\"Available subagents: {agent_infos}\",\n        tools=[extra_tools[\"run_subagent\"]],\n    )\n\n# Create factory\nfactory = AgentFactory(\n    system_agent_factory=create_coordinator,\n    secrets_provider=my_secrets_provider,\n)\n\n# Register subagents\nfactory.add_agent_factory_fn(\n    factory_fn=create_search_agent,\n    info=AgentInfo(name=\"search\", description=\"Web search specialist\")\n)\n</code></pre> <p>Initialize the agent factory.</p> <p>Parameters:</p> Name Type Description Default <code>system_agent_factory</code> <code>SingleAgentFactoryFn | MultiAgentFactoryFn</code> <p>Factory function for creating the main system agent. Can be either SingleAgentFactoryFn (takes only secrets) or MultiAgentFactoryFn (takes secrets, extra_tools, and agent_infos).</p> required <code>system_agent_info</code> <code>AgentInfo | None</code> <p>Optional metadata for the system agent. Defaults to a basic AgentInfo with name=\"system\" and 600s idle timeout.</p> <code>None</code> <code>secrets_provider</code> <code>SecretsProvider | None</code> <p>Optional provider for user-specific secrets (e.g., API keys).</p> <code>None</code>"},{"location":"api/agent/#group_genie.agent.AgentFactory.add_agent_factory_fn","title":"add_agent_factory_fn","text":"<pre><code>add_agent_factory_fn(factory_fn: SingleAgentFactoryFn | MultiAgentFactoryFn, info: AgentInfo)\n</code></pre> <p>Register a new agent factory function.</p> <p>Adds a factory function that can create agents of a specific type. The agent can then be used as a subagent by coordinator agents.</p> <p>Parameters:</p> Name Type Description Default <code>factory_fn</code> <code>SingleAgentFactoryFn | MultiAgentFactoryFn</code> <p>Factory function for creating the agent. Can be either SingleAgentFactoryFn or MultiAgentFactoryFn.</p> required <code>info</code> <code>AgentInfo</code> <p>Metadata about the agent (name, description, idle timeout, etc.).</p> required"},{"location":"api/agent/#group_genie.agent.AgentFactory.agent_info","title":"agent_info","text":"<pre><code>agent_info(name: str) -&gt; AgentInfo\n</code></pre> <p>Get metadata for a specific agent by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the agent.</p> required <p>Returns:</p> Type Description <code>AgentInfo</code> <p><code>AgentInfo</code> for the specified agent.</p>"},{"location":"api/agent/#group_genie.agent.AgentFactory.agent_infos","title":"agent_infos","text":"<pre><code>agent_infos(exclude: str | None = None) -&gt; list[AgentInfo]\n</code></pre> <p>Get metadata for all registered agents.</p> <p>Parameters:</p> Name Type Description Default <code>exclude</code> <code>str | None</code> <p>Optional agent name to exclude from the results (e.g., exclude the coordinator agent itself when providing subagent info).</p> <code>None</code> <p>Returns:</p> Type Description <code>list[AgentInfo]</code> <p>List of <code>AgentInfo</code> for all registered agents except the excluded one.</p>"},{"location":"api/agent/#group_genie.agent.AgentFactory.create_agent","title":"create_agent","text":"<pre><code>create_agent(name: str, owner: str, extra_tools: dict[str, AsyncTool] | None = None) -&gt; Agent\n</code></pre> <p>Create an agent by name for a specific owner.</p> <p>Looks up the registered factory function for the given name and creates an agent instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the agent to create (must be registered via add_agent_factory_fn or be \"system\").</p> required <code>owner</code> <code>str</code> <p>User ID of the agent owner.</p> required <code>extra_tools</code> <code>dict[str, AsyncTool] | None</code> <p>Optional additional tools to provide to the agent. Only used for MultiAgentFactoryFn agents.</p> <code>None</code> <p>Returns:</p> Type Description <code>Agent</code> <p>A new Agent instance configured for the owner.</p>"},{"location":"api/agent/#group_genie.agent.AgentFactory.create_system_agent","title":"create_system_agent","text":"<pre><code>create_system_agent(owner: str, extra_tools: dict[str, AsyncTool]) -&gt; Agent\n</code></pre> <p>Create the main system agent for a specific owner.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>User ID of the agent owner.</p> required <code>extra_tools</code> <code>dict[str, AsyncTool]</code> <p>Additional tools provided by the framework (e.g., run_subagent, get_group_chat_messages).</p> required <p>Returns:</p> Type Description <code>Agent</code> <p>A new system Agent instance.</p>"},{"location":"api/agent/#group_genie.agent.AgentFactory.system_agent_info","title":"system_agent_info","text":"<pre><code>system_agent_info() -&gt; AgentInfo\n</code></pre> <p>Get metadata for the system agent.</p> <p>Returns:</p> Type Description <code>AgentInfo</code> <p><code>AgentInfo</code> for the system agent.</p>"},{"location":"api/agent/#group_genie.agent.SingleAgentFactoryFn","title":"group_genie.agent.SingleAgentFactoryFn  <code>module-attribute</code>","text":"<pre><code>SingleAgentFactoryFn = Callable[[dict[str, str]], Agent]\n</code></pre> <p>Factory function signature for creating standalone agents.</p> <p>Creates agents that process queries independently without orchestrating subagents. These are \"leaf\" agents in an agent hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>secrets</code> <code>dict[str, str]</code> <p>User-specific credentials (e.g., API keys) retrieved from a <code>SecretsProvider</code>. Common keys include \"GOOGLE_API_KEY\", \"BRAVE_API_KEY\", etc.</p> required <p>Returns:</p> Type Description <p>A configured <code>Agent</code> instance ready to process queries.</p> Example <pre><code>def create_search_agent(secrets: dict[str, str]) -&gt; Agent:\n    model = GoogleModel(\n        \"gemini-2.5-flash\",\n        provider=GoogleProvider(api_key=secrets.get(\"GOOGLE_API_KEY\", \"\")),\n    )\n    return DefaultAgent(\n        system_prompt=\"You are a web search specialist\",\n        model=model,\n        builtin_tools=[WebSearchTool()],\n    )\n</code></pre>"},{"location":"api/agent/#group_genie.agent.MultiAgentFactoryFn","title":"group_genie.agent.MultiAgentFactoryFn  <code>module-attribute</code>","text":"<pre><code>MultiAgentFactoryFn = Callable[[dict[str, str], dict[str, AsyncTool], list[AgentInfo]], Agent]\n</code></pre> <p>Factory function signature for creating coordinator agents.</p> <p>Creates agents that can orchestrate other agents as subagents. These coordinator agents receive information about available subagents and framework-provided tools like <code>run_subagent</code> to delegate work.</p> <p>Parameters:</p> Name Type Description Default <code>secrets</code> <code>dict[str, str]</code> <p>User-specific credentials (e.g., API keys) retrieved from a <code>SecretsProvider</code>.</p> required <code>extra_tools</code> <code>dict[str, AsyncTool]</code> <p>Framework-provided tools. Always includes <code>run_subagent</code> for delegating to subagents. May include <code>get_group_chat_messages</code> and other tools depending on the framework configuration.</p> required <code>agent_infos</code> <code>list[AgentInfo]</code> <p>Metadata about all other registered agents (excluding the coordinator itself). Used to inform the coordinator what subagents are available. Each entry is an <code>AgentInfo</code> instance.</p> required <p>Returns:</p> Type Description <p>A configured <code>Agent</code> instance capable of orchestrating subagents.</p> Example <pre><code>def create_coordinator(\n    secrets: dict[str, str],\n    extra_tools: dict[str, AsyncTool],\n    agent_infos: list[AgentInfo],\n) -&gt; Agent:\n    system_prompt = f\"You can delegate to: {[a.name for a in agent_infos]}\"\n    return DefaultAgent(\n        system_prompt=system_prompt,\n        model=\"gemini-2.5-flash\",\n        tools=[extra_tools[\"run_subagent\"]],\n    )\n</code></pre>"},{"location":"api/agent/#group_genie.agent.Decision","title":"group_genie.agent.Decision  <code>module-attribute</code>","text":"<pre><code>Decision = Decision\n</code></pre>"},{"location":"api/datastore/","title":"Storage","text":""},{"location":"api/datastore/#group_genie.datastore.DataStore","title":"group_genie.datastore.DataStore","text":"<pre><code>DataStore(root_path: Path)\n</code></pre> <p>Persistent storage for session messages and agent state.</p> <p>DataStore provides a simple file-based persistence mechanism for Group Genie sessions. It stores data in JSON files organized in a hierarchical directory structure based on session IDs, owner IDs, and component keys.</p> <p>Key characteristics:</p> <ul> <li>Automatic JSON serialization</li> <li>Hierarchical key-based organization via   <code>narrow()</code></li> <li>Asynchronous save operations (non-blocking)</li> <li>Key sanitization for filesystem safety</li> <li>No depth limits on hierarchy</li> </ul> Note <p>This is an experimental snapshot store for development and testing. Do not use in production.</p> Example <pre><code># Create data store for a session\nstore = DataStore(root_path=Path(\".data/sessions/session123\"))\n\n# Save data\nawait store.save(\"messages\", {\"messages\": [...]})\n\n# Load data\ndata = await store.load(\"messages\")\n\n# Create narrowed store for a component\nasync with store.narrow(\"alice\") as alice_store:\n    await alice_store.save(\"agent\", agent_state)\n\n# Path structure: .data/sessions/session123/alice/agent.json\n</code></pre> <p>Initialize a data store with a root directory.</p> <p>Parameters:</p> Name Type Description Default <code>root_path</code> <code>Path</code> <p>Root directory for storing all data files.</p> required"},{"location":"api/datastore/#group_genie.datastore.DataStore.load","title":"load  <code>async</code>","text":"<pre><code>load(key: str) -&gt; Data\n</code></pre> <p>Load data from storage.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Storage key identifying the data to load.</p> required <p>Returns:</p> Type Description <code>Data</code> <p>The loaded data (deserialized from JSON).</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key does not exist in storage.</p>"},{"location":"api/datastore/#group_genie.datastore.DataStore.narrow","title":"narrow  <code>async</code>","text":"<pre><code>narrow(key: str) -&gt; AsyncIterator[DataStore]\n</code></pre> <p>Create a narrowed data store scoped to a subdirectory.</p> <p>Useful for organizing data hierarchically (e.g., by session, then by user, then by component). The key is sanitized for filesystem safety.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Subdirectory name. Special characters are sanitized.</p> required <p>Yields:</p> Type Description <code>AsyncIterator[DataStore]</code> <p>A new <code>DataStore</code> instance rooted at</p> <code>AsyncIterator[DataStore]</code> <p>the subdirectory.</p> Example <pre><code>async with store.narrow(\"alice\") as alice_store:\n    async with alice_store.narrow(\"agent\") as agent_store:\n        await agent_store.save(\"state\", {...})\n# Saves to: root_path/alice/agent/state.json\n</code></pre>"},{"location":"api/datastore/#group_genie.datastore.DataStore.narrow_path","title":"narrow_path","text":"<pre><code>narrow_path(*keys: str) -&gt; Path\n</code></pre> <p>Compute the path for a narrowed key hierarchy.</p> <p>Useful for checking paths or creating directories outside the narrow() context manager.</p> <p>Parameters:</p> Name Type Description Default <code>*keys</code> <code>str</code> <p>Sequence of keys defining the subdirectory hierarchy.</p> <code>()</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the narrowed directory.</p>"},{"location":"api/datastore/#group_genie.datastore.DataStore.save","title":"save","text":"<pre><code>save(key: str, data: Data) -&gt; Future[None]\n</code></pre> <p>Save data to storage asynchronously.</p> <p>Queues the save operation to execute in the background, allowing the caller to continue without blocking.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Storage key for the data.</p> required <code>data</code> <code>Data</code> <p>Data to save (must be JSON-serializable).</p> required <p>Returns:</p> Type Description <code>Future[None]</code> <p>A Future that resolves when the save completes. Can be ignored for fire-and-forget saves.</p>"},{"location":"api/message/","title":"Message","text":""},{"location":"api/message/#group_genie.message.Message","title":"group_genie.message.Message  <code>dataclass</code>","text":"<pre><code>Message(content: str, sender: str, receiver: str | None = None, threads: list[Thread] = list(), attachments: list[Attachment] = list(), request_id: str | None = None)\n</code></pre> <p>Represents a message in a group chat conversation.</p> <p>Messages are the primary unit of communication in Group Genie. Messages can include attachments, reference other threads, and optionally specify receivers and correlation IDs.</p> <p>Attributes:</p> Name Type Description <code>content</code> <code>str</code> <p>The text content of the message.</p> <code>sender</code> <code>str</code> <p>User ID of the message sender. Use \"system\" for agent-generated messages.</p> <code>receiver</code> <code>str | None</code> <p>Optional user ID of the intended recipient. When set by a reasoner, the agent's response will be directed to this user.</p> <code>threads</code> <code>list[Thread]</code> <p>List of referenced threads from other group chats, providing cross- conversation context.</p> <code>attachments</code> <code>list[Attachment]</code> <p>List of files attached to this message.</p> <code>request_id</code> <code>str | None</code> <p>Optional correlation ID for matching request messages with their responses. Set on request messages passed to <code>session.handle()</code> to track which response corresponds to which request.</p> Example <pre><code># Simple message\nmessage = Message(content=\"Hello\", sender=\"alice\")\n\n# Message with attachment and receiver\nmessage = Message(\n    content=\"Please review this document\",\n    sender=\"alice\",\n    receiver=\"bob\",\n    attachments=[Attachment(\n        path=\"/tmp/doc.pdf\",\n        name=\"Document\",\n        media_type=\"application/pdf\"\n    )],\n    request_id=\"req123\"\n)\n\n# Process message\nexecution = session.handle(message)\nresponse = await execution.result()\n\n# Response will have same request_id\nassert response.request_id == \"req123\"\n</code></pre>"},{"location":"api/message/#group_genie.message.Message.deserialize","title":"deserialize  <code>staticmethod</code>","text":"<pre><code>deserialize(message_dict: dict[str, Any]) -&gt; Message\n</code></pre> <p>Reconstruct a <code>Message</code> from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>message_dict</code> <code>dict[str, Any]</code> <p>Dictionary containing message data with nested <code>Thread</code> and <code>Attachment</code> dictionaries, typically obtained from calling asdict() on a <code>Message</code> instance.</p> required <p>Returns:</p> Type Description <code>Message</code> <p>A <code>Message</code> instance with all nested objects properly deserialized.</p>"},{"location":"api/message/#group_genie.message.Attachment","title":"group_genie.message.Attachment  <code>dataclass</code>","text":"<pre><code>Attachment(path: str, name: str, media_type: str)\n</code></pre> <p>Metadata for files attached to group chat messages.</p> <p>Attachments represent files (images, documents, etc.) that accompany messages. They reference local filesystem paths and provide metadata for agents to understand and process the files.</p> <p>The file at the specified path must exist when <code>bytes</code> is called, otherwise an error is raised and the agent run fails.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>str</code> <p>Local filesystem path to the attachment file.</p> <code>name</code> <code>str</code> <p>Display name of the attachment.</p> <code>media_type</code> <code>str</code> <p>MIME type of the attachment (e.g., 'image/png', 'application/pdf').</p> Example <pre><code>attachment = Attachment(\n    path=\"/tmp/report.pdf\",\n    name=\"Monthly Report\",\n    media_type=\"application/pdf\"\n)\n\nmessage = Message(\n    content=\"Please review this report\",\n    sender=\"alice\",\n    attachments=[attachment]\n)\n</code></pre>"},{"location":"api/message/#group_genie.message.Attachment.media_type","title":"media_type  <code>instance-attribute</code>","text":"<pre><code>media_type: str\n</code></pre> <p>MIME type of the attachment.</p>"},{"location":"api/message/#group_genie.message.Attachment.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the attachment.</p>"},{"location":"api/message/#group_genie.message.Attachment.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: str\n</code></pre> <p>Local file path to the attachment.</p>"},{"location":"api/message/#group_genie.message.Attachment.bytes","title":"bytes  <code>async</code>","text":"<pre><code>bytes() -&gt; bytes\n</code></pre> <p>Read the attachment file contents.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The raw bytes of the attachment file.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file at path does not exist.</p>"},{"location":"api/message/#group_genie.message.Attachment.deserialize","title":"deserialize  <code>staticmethod</code>","text":"<pre><code>deserialize(attachment_dict: dict[str, Any]) -&gt; Attachment\n</code></pre> <p>Reconstruct an Attachment from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>attachment_dict</code> <code>dict[str, Any]</code> <p>Dictionary containing attachment data, typically obtained from calling asdict() on an Attachment instance.</p> required <p>Returns:</p> Type Description <code>Attachment</code> <p>An Attachment instance.</p>"},{"location":"api/message/#group_genie.message.Thread","title":"group_genie.message.Thread  <code>dataclass</code>","text":"<pre><code>Thread(id: str, messages: list[Message])\n</code></pre> <p>Reference to a conversation thread from another group chat.</p> <p>Threads allow messages to include context from other group conversations, enabling agents to access related discussions. Thread IDs are application-managed and typically correspond to <code>GroupSession</code> IDs.</p> <p>Applications are responsible for loading thread messages from the referenced group session and including them in the <code>Thread</code> object.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier of the referenced thread (typically a GroupSession ID).</p> <code>messages</code> <code>list[Message]</code> <p>List of messages from the referenced thread.</p> Example <pre><code># Load messages from another session\nother_session_messages = await GroupSession.load_messages(other_datastore)\n\n# Include as thread reference\nthread = Thread(id=\"session123\", messages=other_session_messages)\nmessage = Message(\n    content=\"Following up on the previous discussion\",\n    sender=\"alice\",\n    threads=[thread]\n)\n</code></pre>"},{"location":"api/message/#group_genie.message.Thread.deserialize","title":"deserialize  <code>staticmethod</code>","text":"<pre><code>deserialize(thread_dict: dict[str, Any]) -&gt; Thread\n</code></pre> <p>Reconstruct a <code>Thread</code> from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>thread_dict</code> <code>dict[str, Any]</code> <p>Dictionary containing thread data with 'id' and 'messages' keys, typically obtained from calling asdict() on a <code>Thread</code> instance.</p> required <p>Returns:</p> Type Description <code>Thread</code> <p>A <code>Thread</code> instance.</p>"},{"location":"api/reasoner/","title":"Reasoner","text":""},{"location":"api/reasoner/#group_genie.reasoner.GroupReasoner","title":"group_genie.reasoner.GroupReasoner","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for group reasoning logic.</p> <p>Group reasoners analyze incoming group chat messages and decide whether to ignore them or generate a query for downstream agents. They maintain conversation history across update messages supplied via <code>run()</code> calls.</p> <p>State persistence is managed automatically by the framework and stored in JSON format. Persisted state is never transferred between different owners (users).</p> Example <pre><code>class MyGroupReasoner(GroupReasoner):\n    def __init__(self, system_prompt: str):\n        self._history = []\n        self._processed = 0\n        self._system_prompt = system_prompt\n\n    @property\n    def processed(self) -&gt; int:\n        return self._processed\n\n    def get_serialized(self):\n        return {\"history\": self._history, \"processed\": self._processed}\n\n    def set_serialized(self, state):\n        self._history = state[\"history\"]\n        self._processed = state[\"processed\"]\n\n    async def run(self, updates: list[Message]) -&gt; Response:\n        # Analyze messages and decide\n        self._processed += len(updates)\n        return Response(decision=Decision.DELEGATE, query=\"...\")\n</code></pre>"},{"location":"api/reasoner/#group_genie.reasoner.GroupReasoner.processed","title":"processed  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>processed: int\n</code></pre> <p>Number of messages processed so far by this reasoner.</p> <p>Used for tracking conversation history and providing context to the reasoner.</p>"},{"location":"api/reasoner/#group_genie.reasoner.GroupReasoner.get_serialized","title":"get_serialized  <code>abstractmethod</code>","text":"<pre><code>get_serialized() -&gt; Any\n</code></pre> <p>Serialize reasoner state for persistence.</p> <p>Returns conversation history and any other state needed to resume the reasoner after a restart. Called automatically by the framework before saving to <code>DataStore</code>.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Serializable state (must be JSON-compatible). Implementation-specific format.</p>"},{"location":"api/reasoner/#group_genie.reasoner.GroupReasoner.run","title":"run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>run(updates: list[Message]) -&gt; Response\n</code></pre> <p>Analyze message updates and decide whether to delegate.</p> <p>Processes new group messages in the context of the entire conversation history and decides whether to ignore them or generate a query for agent processing.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>list[Message]</code> <p>List of new messages to process. Must not be empty. Represents messages that arrived since the last <code>run()</code> call.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>Response from group-sense containing the decision (IGNORE or DELEGATE) and optional delegation parameters (query and receiver).</p>"},{"location":"api/reasoner/#group_genie.reasoner.GroupReasoner.set_serialized","title":"set_serialized  <code>abstractmethod</code>","text":"<pre><code>set_serialized(serialized: Any)\n</code></pre> <p>Restore reasoner state from serialized data.</p> <p>Reconstructs conversation history and internal state from previously serialized data. Called automatically by the framework after loading from <code>DataStore</code>.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>Any</code> <p>Previously serialized state from <code>get_serialized()</code>.</p> required"},{"location":"api/reasoner/#group_genie.reasoner.GroupReasonerFactory","title":"group_genie.reasoner.GroupReasonerFactory","text":"<pre><code>GroupReasonerFactory(group_reasoner_factory_fn: GroupReasonerFactoryFn, group_reasoner_idle_timeout: float | None = None, secrets_provider: SecretsProvider | None = None)\n</code></pre> <p>               Bases: <code>GroupReasonerFactory</code></p> <p>Factory for creating group reasoner instances.</p> <p><code>GroupReasonerFactory</code> creates reasoner instances customized for specific users (owners). It provides user-specific secrets and stores idle timeout configuration.</p> <p>Each user typically gets their own reasoner instance to maintain independent reasoning state and conversation history.</p> Example <pre><code>def create_reasoner(secrets: dict[str, str], owner: str) -&gt; GroupReasoner:\n    template = \"You are assisting {owner} in a group chat...\"\n    system_prompt = template.format(owner=owner)\n    return DefaultGroupReasoner(system_prompt=system_prompt)\n\nfactory = GroupReasonerFactory(\n    group_reasoner_factory_fn=create_reasoner,\n    group_reasoner_idle_timeout=600,\n    secrets_provider=my_secrets_provider,\n)\n\n# Factory creates reasoner for specific user\nreasoner = factory.create_group_reasoner(owner=\"alice\")\n</code></pre> <p>Initialize the group reasoner factory.</p> <p>Parameters:</p> Name Type Description Default <code>group_reasoner_factory_fn</code> <code>GroupReasonerFactoryFn</code> <p>Factory function that creates a GroupReasoner for a specific owner. Receives secrets and owner ID.</p> required <code>group_reasoner_idle_timeout</code> <code>float | None</code> <p>Optional timeout in seconds after which an idle reasoner is stopped to free resources. Defaults to 600s (10 minutes).</p> <code>None</code> <code>secrets_provider</code> <code>SecretsProvider | None</code> <p>Optional provider for user-specific secrets (e.g., API keys).</p> <code>None</code>"},{"location":"api/reasoner/#group_genie.reasoner.GroupReasonerFactory.create_group_reasoner","title":"create_group_reasoner","text":"<pre><code>create_group_reasoner(owner: str, **kwargs: Any) -&gt; GroupReasoner\n</code></pre> <p>Create a group reasoner instance for a specific owner.</p> <p>Retrieves secrets for the owner and creates a reasoner instance using the factory function.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>str</code> <p>User ID of the reasoner owner.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to the factory function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GroupReasoner</code> <p>A new <code>GroupReasoner</code> instance configured for the owner.</p>"},{"location":"api/reasoner/#group_genie.reasoner.GroupReasonerFactoryFn","title":"group_genie.reasoner.GroupReasonerFactoryFn  <code>module-attribute</code>","text":"<pre><code>GroupReasonerFactoryFn = Callable[[dict[str, str], str], GroupReasoner]\n</code></pre> <p>Factory function signature for creating group reasoners.</p> <p>Creates reasoner instances customized for specific users (owners). Each user typically gets their own reasoner instance to enable concurrent reasoning for different users.</p> <p>Parameters:</p> Name Type Description Default <code>secrets</code> <code>dict[str, str]</code> <p>User-specific credentials (e.g., API keys) retrieved from a <code>SecretsProvider</code>. Common keys include \"GOOGLE_API_KEY\", \"BRAVE_API_KEY\", etc.</p> required <code>owner</code> <code>str</code> <p>Username of the reasoner owner. Can be used to personalize behavior (e.g., formatting system prompts with the owner's name).</p> required <p>Returns:</p> Type Description <p>A configured <code>GroupReasoner</code> instance for the specified owner.</p> Example <pre><code>def create_reasoner(secrets: dict[str, str], owner: str) -&gt; GroupReasoner:\n    template = \"You are assisting {owner} in a group chat...\"\n    system_prompt = template.format(owner=owner)\n    model = GoogleModel(\n        \"gemini-2.5-flash\",\n        provider=GoogleProvider(api_key=secrets.get(\"GOOGLE_API_KEY\", \"\")),\n    )\n    return DefaultGroupReasoner(\n        system_prompt=system_prompt,\n        model=model,\n    )\n</code></pre>"},{"location":"api/secrets/","title":"Secrets","text":""},{"location":"api/secrets/#group_genie.secrets.SecretsProvider","title":"group_genie.secrets.SecretsProvider","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for providing user-specific secrets.</p> <p><code>SecretsProvider</code> supplies credentials (like API keys) to agents and reasoners on a per-user basis. This enables agents to act on behalf of individual users with their own credentials while preventing unauthorized access to other users' resources.</p> <p>Implementations should return secrets as key-value pairs where keys are credential names (e.g., \"GOOGLE_API_KEY\") and values are the actual credentials.</p> Example <pre><code>class EnvironmentSecretsProvider(SecretsProvider):\n    def get_secrets(self, username: str) -&gt; dict[str, str] | None:\n        # For development: use environment variables for all users\n        return {\n            \"GOOGLE_API_KEY\": os.getenv(\"GOOGLE_API_KEY\", \"\"),\n            \"OPENAI_API_KEY\": os.getenv(\"OPENAI_API_KEY\", \"\"),\n        }\n\nclass DatabaseSecretsProvider(SecretsProvider):\n    def get_secrets(self, username: str) -&gt; dict[str, str] | None:\n        # For production: fetch user-specific credentials from database\n        user = database.get_user(username)\n        if not user:\n            return None\n        return {\n            \"GOOGLE_API_KEY\": user.google_api_key,\n            \"OPENAI_API_KEY\": user.openai_api_key,\n        }\n</code></pre>"},{"location":"api/secrets/#group_genie.secrets.SecretsProvider.get_secrets","title":"get_secrets  <code>abstractmethod</code>","text":"<pre><code>get_secrets(username: str) -&gt; dict[str, str] | None\n</code></pre> <p>Retrieve secrets for a specific user.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User ID to fetch secrets for.</p> required <p>Returns:</p> Type Description <code>dict[str, str] | None</code> <p>Dictionary mapping credential names to values, or None if the user has no secrets configured.</p>"},{"location":"api/session/","title":"Session","text":""},{"location":"api/session/#group_genie.session.GroupSession","title":"group_genie.session.GroupSession","text":"<pre><code>GroupSession(id: str, group_reasoner_factory: GroupReasonerFactory, agent_factory: AgentFactory, data_store: DataStore | None = None, preferences_source: PreferencesSource | None = None)\n</code></pre> <p>Main entry point for managing group chat sessions with AI agents.</p> <p><code>GroupSession</code> orchestrates the flow of messages through group reasoners and agents, managing their lifecycle and state persistence. It maintains message ordering, handles concurrent processing for different users, and provides graceful shutdown.</p> <p>Messages are stored internally in the order of <code>handle()</code> calls and processed concurrently for different senders. Messages from the same sender are always processed sequentially.</p> <p>Persisted session state (messages and agent/reasoner state) is automatically loaded during initialization if a <code>DataStore</code> is provided.</p> Example <pre><code>session = GroupSession(\n    id=\"session123\",\n    group_reasoner_factory=create_group_reasoner_factory(),\n    agent_factory=create_agent_factory(),\n    data_store=DataStore(root_path=Path(\".data/sessions/session123\")),\n)\n\n# Handle incoming message\nexecution = session.handle(\n    Message(content=\"What's the weather in Vienna?\", sender=\"alice\")\n)\n\n# Process execution\nasync for elem in execution.stream():\n    match elem:\n        case Decision.DELEGATE:\n            print(\"Query delegated to agent\")\n        case Approval() as approval:\n            approval.approve()\n        case Message() as response:\n            print(f\"Response: {response.content}\")\n\n# Gracefully stop session\nsession.stop()\nawait session.join()\n</code></pre> <p>Initialize a new group chat session.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique identifier for this session. Used as the root key for persisted state in the <code>DataStore</code>.</p> required <code>group_reasoner_factory</code> <code>GroupReasonerFactory</code> <p>Factory for creating group reasoner instances that decide when to delegate messages to agents.</p> required <code>agent_factory</code> <code>AgentFactory</code> <p>Factory for creating agent instances that process delegated queries.</p> required <code>data_store</code> <code>DataStore | None</code> <p>Optional persistent storage for session messages and agent state. If provided, session state is automatically loaded on initialization and saved after each message. Experimental feature not suitable for production.</p> <code>None</code> <code>preferences_source</code> <code>PreferencesSource | None</code> <p>Optional source for user-specific preferences that are included in agent prompts.</p> <code>None</code>"},{"location":"api/session/#group_genie.session.GroupSession.get_group_chat_messages","title":"get_group_chat_messages  <code>async</code>","text":"<pre><code>get_group_chat_messages() -&gt; str\n</code></pre> <p>Returns the group chat messages as a JSON string.</p>"},{"location":"api/session/#group_genie.session.GroupSession.handle","title":"handle","text":"<pre><code>handle(message: Message) -&gt; Execution\n</code></pre> <p>Process an incoming group chat message.</p> <p>Adds the message to the session's message history and initiates processing through group reasoners and agents. Returns immediately with an <code>Execution</code> object that can be used to retrieve results.</p> <p>Messages are stored in the order <code>handle()</code> is called. For different senders, messages are processed concurrently. For the same sender, messages are processed sequentially to maintain conversation coherence.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>The message to process.</p> required <p>Returns:</p> Type Description <code>Execution</code> <p>An <code>Execution</code> object that provides access to the processing stream and final result.</p>"},{"location":"api/session/#group_genie.session.GroupSession.join","title":"join  <code>async</code>","text":"<pre><code>join()\n</code></pre> <p>Wait for the session to complete shutdown.</p> <p>Blocks until all internal workers, agents, and reasoners have stopped. Must be called after stop() to ensure proper cleanup.</p>"},{"location":"api/session/#group_genie.session.GroupSession.load_messages","title":"load_messages  <code>async</code> <code>staticmethod</code>","text":"<pre><code>load_messages(data_store: DataStore) -&gt; list[Message] | None\n</code></pre> <p>Load persisted messages from a data store.</p> <p>Utility method for accessing session messages without creating a full <code>GroupSession</code> instance. Automatically called during session initialization.</p> <p>Parameters:</p> Name Type Description Default <code>data_store</code> <code>DataStore</code> <p><code>DataStore</code> containing the session data to load.</p> required <p>Returns:</p> Type Description <code>list[Message] | None</code> <p>List of messages if the session exists in the data store, None otherwise.</p>"},{"location":"api/session/#group_genie.session.GroupSession.request_ids","title":"request_ids","text":"<pre><code>request_ids() -&gt; Future[set[str]]\n</code></pre> <p>Retrieve all request IDs from messages in this session.</p> <p>Returns:</p> Type Description <code>Future[set[str]]</code> <p>A Future that resolves to a set of request IDs from all messages that have been processed by this session. Only includes messages with non-None request_id values.</p>"},{"location":"api/session/#group_genie.session.GroupSession.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Request graceful shutdown of the session.</p> <p>Allows currently processing messages to complete before stopping all group reasoners and agents. Call join() after stop() to wait for shutdown completion.</p>"},{"location":"api/session/#group_genie.session.Execution","title":"group_genie.session.Execution","text":"<pre><code>Execution(preferences_source: PreferencesSource | None = None)\n</code></pre> <p>Represents the asynchronous processing of a message through the system.</p> <p><code>Execution</code> provides access to the stream of events (decision, approvals, and responses) generated while processing a message. It allows applications to monitor progress, handle approval requests, and retrieve the final result.</p> <p>The execution stream follows a guaranteed order:</p> <ol> <li>One <code>Decision</code> (IGNORE or DELEGATE)</li> <li>Zero or more <code>Approval</code> requests (only    if DELEGATE and tools/subagents are called)</li> <li>One <code>Message</code> (only if DELEGATE, containing the    agent's response)</li> </ol> <p>Multiple calls to <code>stream()</code> are safe and will return the cached result after the first complete iteration.</p> Example <pre><code>execution = session.handle(message)\n\n# Stream events\nasync for elem in execution.stream():\n    match elem:\n        case Decision.IGNORE:\n            print(\"Message ignored by reasoner\")\n        case Decision.DELEGATE:\n            print(\"Message delegated to agent\")\n        case Approval() as approval:\n            print(f\"Tool call requires approval: {approval}\")\n            approval.approve()\n        case Message() as response:\n            print(f\"Agent response: {response.content}\")\n\n# Or get result directly (auto-approves all tool calls)\nresult = await execution.result()\nif result:\n    print(f\"Response: {result.content}\")\n</code></pre>"},{"location":"api/session/#group_genie.session.Execution.result","title":"result  <code>async</code>","text":"<pre><code>result() -&gt; Message | None\n</code></pre> <p>Retrieve the final message result, automatically approving all tool calls.</p> <p>Convenience method that streams through all events, auto-approving any <code>Approval</code> requests, and returns the final <code>Message</code>. Useful when manual approval handling is not needed.</p> <p>Returns:</p> Type Description <code>Message | None</code> <p>The agent's response <code>Message</code> if the reasoner delegated, None if the reasoner ignored the message.</p>"},{"location":"api/session/#group_genie.session.Execution.stream","title":"stream  <code>async</code>","text":"<pre><code>stream() -&gt; AsyncIterator[Decision | Approval | Message]\n</code></pre> <p>Stream execution events as they occur.</p> <p>Yields events in guaranteed order:</p> <ol> <li>One <code>Decision</code> (IGNORE or DELEGATE)</li> <li>Zero or more <code>Approval</code> requests    (if DELEGATE and tools are called)</li> <li>One <code>Message</code> (if DELEGATE, containing the    final response)</li> </ol> <p>Agent execution blocks on <code>Approval</code> requests until they are approved or denied. Applications must handle all emitted Approvals by calling <code>approve()</code> or <code>deny()</code>.</p> <p>If auto_approve is enabled in the <code>ApprovalContext</code>, <code>Approval</code> events are not emitted and all tool calls are automatically approved.</p> <p>Can be called multiple times. After the first complete iteration, cached results are returned immediately.</p> <p>Yields:</p> Type Description <code>AsyncIterator[Decision | Approval | Message]</code> <p><code>Decision</code>,</p> <code>AsyncIterator[Decision | Approval | Message]</code> <p><code>Approval</code>, or</p> <code>AsyncIterator[Decision | Approval | Message]</code> <p><code>Message</code> objects representing execution</p> <code>AsyncIterator[Decision | Approval | Message]</code> <p>progress.</p>"},{"location":"api/session/#group_genie.preferences.PreferencesSource","title":"group_genie.preferences.PreferencesSource","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for providing user-specific preferences.</p> <p><code>PreferencesSource</code> supplies user preferences that customize agent behavior and response style. Preferences are typically free-form text (often bullet points) describing formatting, tone, verbosity, and other stylistic choices.</p> <p>Preferences are included in agent prompts to personalize responses without modifying agent system prompts.</p> Example <pre><code>class DatabasePreferencesSource(PreferencesSource):\n    async def get_preferences(self, username: str) -&gt; str | None:\n        user = await database.get_user(username)\n        if not user or not user.preferences:\n            return None\n\n        return user.preferences\n        # Example preferences:\n        # \"- Prefer concise responses\n        #  - Use bullet points for lists\n        #  - Include code examples when relevant\n        #  - Avoid technical jargon\"\n\nclass StaticPreferencesSource(PreferencesSource):\n    def __init__(self, preferences_map: dict[str, str]):\n        self._preferences = preferences_map\n\n    async def get_preferences(self, username: str) -&gt; str | None:\n        return self._preferences.get(username)\n</code></pre>"},{"location":"api/session/#group_genie.preferences.PreferencesSource.get_preferences","title":"get_preferences  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_preferences(username: str) -&gt; str | None\n</code></pre> <p>Retrieve preferences for a specific user.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>User ID to fetch preferences for.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Free-form text describing user preferences, or None if the user has no preferences configured. When None, preferences are not included in agent prompts.</p>"},{"location":"api/provider/pydantic_ai/","title":"Pydantic AI","text":""},{"location":"api/provider/pydantic_ai/#group_genie.agent.provider.pydantic_ai.DefaultAgent","title":"group_genie.agent.provider.pydantic_ai.DefaultAgent","text":"<pre><code>DefaultAgent(system_prompt: str, model: str | Model, model_settings: ModelSettings | None = None, toolsets: list[AbstractToolset] = [], tools: list[AsyncTool] = [], builtin_tools: list[AbstractBuiltinTool] = [])\n</code></pre> <p>               Bases: <code>Stateful</code>, <code>Agent</code></p> <p>Default agent implementation using pydantic-ai.</p> <p>DefaultAgent is a ready-to-use Agent implementation built on pydantic-ai. It supports conversation state management, tool calling with approval workflows, and MCP server lifecycle management.</p> <p>The agent can be configured with:</p> <ul> <li>Custom system prompts</li> <li>Any pydantic-ai compatible model</li> <li>Toolsets (collections of tools, including MCP servers)</li> <li>Individual tools (async functions)</li> <li>Built-in tools (like <code>WebSearchTool</code>)</li> </ul> <p>For model and tool configuration details, consult the pydantic-ai documentation.</p> Example <pre><code>from pydantic_ai.builtin_tools import WebSearchTool\nfrom pydantic_ai.models.google import GoogleModelSettings\n\nagent = DefaultAgent(\n    system_prompt=\"You are a helpful assistant\",\n    model=\"gemini-2.5-flash\",\n    model_settings=GoogleModelSettings(\n        google_thinking_config={\n            \"thinking_budget\": -1,\n            \"include_thoughts\": True,\n        }\n    ),\n    builtin_tools=[WebSearchTool()],\n)\n</code></pre> <p>Initialize a pydantic-ai based agent.</p> <p>Parameters:</p> Name Type Description Default <code>system_prompt</code> <code>str</code> <p>System prompt that defines the agent's behavior and personality.</p> required <code>model</code> <code>str | Model</code> <p>Model identifier or pydantic-ai Model instance. Can be any model supported by pydantic-ai.</p> required <code>model_settings</code> <code>ModelSettings | None</code> <p>Optional model-specific settings. See pydantic-ai documentation for available settings per model provider.</p> <code>None</code> <code>toolsets</code> <code>list[AbstractToolset]</code> <p>List of tool collections (including MCP servers). Use this for organized sets of related tools.</p> <code>[]</code> <code>tools</code> <code>list[AsyncTool]</code> <p>List of individual async functions to make available as tools.</p> <code>[]</code> <code>builtin_tools</code> <code>list[AbstractBuiltinTool]</code> <p>List of pydantic-ai built-in tools (e.g., WebSearchTool).</p> <code>[]</code>"},{"location":"api/provider/pydantic_ai/#group_genie.agent.provider.pydantic_ai.DefaultAgent.mcp","title":"mcp  <code>async</code>","text":"<pre><code>mcp()\n</code></pre> <p>Manage MCP server lifecycle for this agent.</p> <p>Delegates MCP server management to the underlying pydantic-ai agent, which handles connection and cleanup of any MCP servers included in toolsets.</p> <p>Yields:</p> Type Description <p>This agent instance.</p>"},{"location":"api/provider/pydantic_ai/#group_genie.agent.provider.pydantic_ai.DefaultAgent.run","title":"run  <code>async</code>","text":"<pre><code>run(input: AgentInput, callback: ApprovalCallback) -&gt; str\n</code></pre> <p>Process a query and return a response.</p> <p>Runs the pydantic-ai agent with the provided query, attachments, and preferences. Tool calls are intercepted and routed through the approval callback, allowing the application to approve or deny tool execution.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>AgentInput</code> <p>Query, attachments, and preferences to process.</p> required <code>callback</code> <code>ApprovalCallback</code> <p>Approval callback for tool calls. Called for each tool execution to request approval.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The agent's response as a string.</p>"},{"location":"api/provider/pydantic_ai/#group_genie.agent.provider.pydantic_ai.DefaultGroupReasoner","title":"group_genie.agent.provider.pydantic_ai.DefaultGroupReasoner","text":"<pre><code>DefaultGroupReasoner(system_prompt: str, model: str | Model | None = None, model_settings: ModelSettings | None = None)\n</code></pre> <p>               Bases: <code>GroupReasoner</code></p> <p>Default group reasoner implementation using group-sense.</p> <p>DefaultGroupReasoner wraps the group-sense library's DefaultGroupReasoner, adapting Group Genie's Message types to group-sense's message format.</p> <p>The reasoner analyzes group chat messages according to the system prompt's engagement criteria and decides whether to delegate queries to agents.</p> <p>For model and configuration details, consult the group-sense and pydantic-ai documentation. Tested with gemini-2.5-flash but compatible with any pydantic-ai supported model.</p> Example <pre><code>reasoner = DefaultGroupReasoner(\n    system_prompt='''\n        You are monitoring a group chat for {owner}.\n        Delegate when {owner} asks questions.\n        Generate self-contained queries.\n    '''.format(owner=\"alice\"),\n    model=\"gemini-2.5-flash\",\n)\n\n# Process messages\nresponse = await reasoner.run([\n    Message(content=\"What's the weather?\", sender=\"alice\")\n])\n\nif response.decision == Decision.DELEGATE:\n    print(f\"Query: {response.query}\")\n</code></pre> <p>Initialize a group-sense based reasoner.</p> <p>Parameters:</p> Name Type Description Default <code>system_prompt</code> <code>str</code> <p>System prompt defining the engagement criteria. Should describe when to delegate messages and how to transform them into self-contained queries.</p> required <code>model</code> <code>str | Model | None</code> <p>Optional model identifier or pydantic-ai Model instance. Defaults to the model configured in group-sense. Can be any model supported by pydantic-ai.</p> <code>None</code> <code>model_settings</code> <code>ModelSettings | None</code> <p>Optional model-specific settings. See pydantic-ai documentation for available settings per model provider.</p> <code>None</code>"},{"location":"api/provider/pydantic_ai/#group_genie.agent.provider.pydantic_ai.DefaultGroupReasoner.run","title":"run  <code>async</code>","text":"<pre><code>run(updates: list[Message]) -&gt; Response\n</code></pre> <p>Analyze message updates and decide whether to delegate.</p> <p>Converts Group Genie messages to group-sense format and delegates to the underlying group-sense reasoner for processing.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>list[Message]</code> <p>List of new messages to analyze.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>Response from group-sense with decision and optional query/receiver.</p>"},{"location":"api/provider/pydantic_ai/#group_genie.agent.provider.pydantic_ai.ToolFilter","title":"group_genie.agent.provider.pydantic_ai.ToolFilter  <code>dataclass</code>","text":"<pre><code>ToolFilter(included: list[str] | None = None, excluded: list[str] | None = None)\n</code></pre> <p>Filter function for selectively exposing tools to agents based on whitelists and blacklists.</p> <p>This class is designed to be passed to pydantic-ai's <code>FilteredToolset</code> or the <code>filtered()</code> method on any toolset. It implements a callable filter that receives the run context and tool definition for each tool and returns whether the tool should be available.</p> <p>The filter operates as follows: - If <code>included</code> is specified, only tools in the whitelist are allowed - If <code>excluded</code> is specified, tools in the blacklist are rejected - If both are specified, a tool must be in <code>included</code> and not in <code>excluded</code> - If neither is specified, all tools are allowed</p> Example <pre><code> filter = ToolFilter(included=[\"read_file\", \"write_file\"])\n filtered_toolset = my_toolset.filtered(filter)\n</code></pre> <p>Attributes:</p> Name Type Description <code>included</code> <code>list[str] | None</code> <p>Optional whitelist of tool names. If provided, only tools with names in this list will be allowed through the filter.</p> <code>excluded</code> <code>list[str] | None</code> <p>Optional blacklist of tool names. If provided, tools with names in this list will be rejected by the filter.</p>"}]}