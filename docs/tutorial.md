# Tutorial

This tutorial walks you through a complete example that demonstrates how Group Genie enables AI agents to participate in group chat conversations. You'll learn how to set up a group session, configure a group reasoner to detect conversation patterns, and connect an agent that responds to queries generated by the group reasoner.

## About Group Genie

While many AI agents excel at responding to direct queries from individual users, they typically cannot handle multi-party conversations where relevant information emerges from complex exchanges between multiple participants. Group Genie combines [Group Sense](https://gradion-ai.github.io/group-sense/)'s intelligent pattern detection with a flexible agent integration layer, allowing existing single-user agents to participate naturally in group chats without requiring any modification to the agents themselves.

## Example Scenario

In this example, we'll create a fact-checking assistant that monitors a group chat for factual inconsistencies. When the group reasoner detects contradictory statements, it sends a self-contained query, reformulated from the conversation context, to the system agent to verify facts through web search and respond to the group.

Consider this group chat exchange:

- `user1`: "I'm going to Vienna tomorrow"
- `user2`: "Enjoy your time there!"
- `user3`: "Cool, plan a visit to the Hofbräuhaus!"

The third message contains a factual inconsistency (Hofbräuhaus is in Munich, not Vienna). The group reasoner will detect this and delegate to the system agent, which will search the web, identify the mistake, and respond with a clarification.

## Core Components

The tutorial demonstrates four essential components:

### Group Session

[`GroupSession`][group_genie.session.GroupSession] is the main entry point that orchestrates message flow through group reasoners and agents. It provides concurrent processing for different users while ensuring messages from the same sender are processed sequentially. It also manages the lifecycle of both reasoners and agents.

### Group Reasoner

A [`GroupReasoner`][group_genie.reasoner.base.GroupReasoner] analyzes group chat messages and decides whether to ignore them or generate queries for agents. In this example, we use [`DefaultGroupReasoner`][group_genie.agent.provider.pydantic_ai.group.DefaultGroupReasoner] configured with a [fact-checking](https://github.com/gradion-ai/group-genie/blob/main/examples/prompts/reasoner/fact_check.md) prompt that detects contradictory statements between messages.

### System Agent

The system agent is the primary target for processing delegated queries generated by the group reasoner. It can be any [`Agent`][group_genie.agent.base.Agent]; the name *system agent* reflects that it can serve as a facade to a larger system of agents (e.g. acting as a coordinator that delegates to subagents), but it can also be a standalone agent that directly handles queries.

In this example, we use a standalone [`DefaultAgent`][group_genie.agent.provider.pydantic_ai.agent.default.DefaultAgent] with access to web search through an MCP server, allowing it to verify facts by searching online.

### Factories

Each group chat participant owns both a group reasoner instance and a system agent instance, allowing independent reasoning state and credentials. These are created by:

- [`GroupReasonerFactory`][group_genie.reasoner.factory.GroupReasonerFactory] creates group reasoners with user-specific system prompts and reasoning states
- [`AgentFactory`][group_genie.agent.factory.AgentFactory] creates system agent instances with user-specific credentials, enabling agents to act on behalf of individual group members

## Implementation Walkthrough

### Secrets Provider

We implement [`SecretsProvider`][group_genie.secrets.SecretsProvider], an interface designed to retrieve user-specific credentials:

```python title="examples/factory/provider.py"
--8<-- "examples/factory/provider.py:imports"

--8<-- "examples/factory/provider.py:secrets-provider"
```

In this development example, we just return the same set of environment variables for all users. In production, you would implement per-user credential storage and retrieval.

### Group Reasoner Factory

We use the `get_group_reasoner_factory` helper to obtain a [`GroupReasonerFactory`][group_genie.reasoner.factory.GroupReasonerFactory] for creating user-specific reasoner instances:

```python title="examples/factory/reasoner.py"
--8<-- "examples/factory/reasoner.py:imports"

--8<-- "examples/factory/reasoner.py:create-group-reasoner"
--8<-- "examples/factory/reasoner.py:group-reasoner-factory"
```

The `create_group_reasoner` function receives a system prompt template, secrets, and the owner's username and returns a configured [`GroupReasoner`][group_genie.reasoner.base.GroupReasoner]. It:

1. Creates a Gemini model instance with the owner's Google API key from their secrets
2. Formats the system prompt template with the owner's username
3. Returns a [`DefaultGroupReasoner`][group_genie.agent.provider.pydantic_ai.group.DefaultGroupReasoner] configured with the formatted system prompt and model

### Agent Factory

We use the `get_agent_factory` helper to obtain an [`AgentFactory`][group_genie.agent.factory.AgentFactory] for creating user-specific system agent instances:

```python title="examples/factory/agent_1.py"
--8<-- "examples/factory/agent_1.py:imports"
 
--8<-- "examples/factory/agent_1.py:create-system-agent"
--8<-- "examples/factory/agent_1.py:agent-factory"
```

The `create_system_agent` function receives the owner's secrets and returns a configured [`Agent`][group_genie.agent.base.Agent]. It:

1. Configures a Brave Search MCP server with the owner's Brave API key
2. Configures a Gemini model instance with the owner's Google API key
3. Returns a [`DefaultAgent`][group_genie.agent.provider.pydantic_ai.agent.default.DefaultAgent] configured with:
    - A system prompt instructing it to search the web for fact-checking
    - The configured Gemini model
    - The configured Brave Search MCP server

### Group Session

Now we bring everything together by creating a [`GroupSession`][group_genie.session.GroupSession]:

```python title="examples/guide/tutorial.py"

--8<-- "examples/guide/tutorial.py:imports"

--8<-- "examples/guide/tutorial.py:complete-execution"
--8<-- "examples/guide/tutorial.py:main"
```

This code:

1. Creates a [secrets provider](#secrets-provider) to supply API keys
2. Generates a unique session ID for this group chat
3. Initializes a [`GroupSession`][group_genie.session.GroupSession] with:
    - A group reasoner factory configured for fact-checking
    - An agent factory that creates system agents with web search capabilities
    - A [`DataStore`][group_genie.datastore.DataStore] for persisting messages, reasoner and agent states
4. Defines a sample group chat with three messages, where the third contains a factual inconsistency
5. Handles each message by calling [`handle()`][group_genie.session.GroupSession.handle], which returns an [`Execution`][group_genie.session.Execution] object
6. Concurrently consumes execution [`stream`][group_genie.session.Execution.stream]s with the `complete_execution` helper and `asyncio.gather()`

An execution [`stream`][group_genie.session.Execution.stream] yields three types of elements:

- `Decision`: The group reasoner's decision about whether to ignore or delegate the message
- [`Approval`][group_genie.agent.approval.Approval]: Requests for approval of tool calls (e.g., web searches)
- [`Message`][group_genie.message.Message]: The agent's response to be sent to the group

In this example, we log all events and automatically approve all tool calls. In a production application, you might implement selective approval logic or user confirmation for sensitive operations.

## Running the Example

!!! note "Development Setup"
    To set up the environment for running the example, see [Development Setup](installation.md#development-setup).

To run this example:

1. Set up your API keys:
   ```bash
   export GOOGLE_API_KEY="your-gemini-api-key"
   export BRAVE_API_KEY="your-brave-search-api-key"
   ```

2. Run the tutorial script:
   ```bash
   python examples/guide/tutorial.py
   ```

The output will show the group reasoner detecting the factual contradiction and the agent searching the web to verify that Hofbräuhaus is actually in Munich, not Vienna. The agent will then generate a response clarifying this mistake for the group. The output should look like this:

```
2025-11-05 11:06:15,947 DEBUG __main__: Decision.IGNORE
2025-11-05 11:06:17,085 DEBUG __main__: Decision.IGNORE
2025-11-05 11:06:19,526 DEBUG __main__: Decision.DELEGATE
2025-11-05 11:06:20,336 DEBUG __main__: [sender="system"] brave_web_search(query='Hofbräuhaus location')
2025-11-05 11:06:22,399 DEBUG __main__: Message(content='The Hofbräuhaus is a famous beer hall located in Munich, Germany, not Vienna, Austria. Therefore, a visit to the Hofbräuhaus would not be possible if you are going to Vienna.', sender='system', receiver=None, threads=[], attachments=[], request_id=None)
```
